************************ Dynamic Link Library ***************************
********* testJni1.java ************
public class testJni1
{
static{
System.loadLibrary("native");
}
public static void main(String args[])
{
System.out.println("Addition is "+ new testJni1().add(10,20));
}
private native int add(int n1,int n2);
}

****** Compiling the file ********
Command:-
gescoe@gescoe-optiplex-3020:~/Documents/AY21-22/LP-1$ javac -h . testJni1.java

********** testJni1.c **********
#include<jni.h>
#include<stdio.h>
#include "testJni1.h" JNIEXPORT jint JNICALL Java_testJni1_add
(JNIEnv *env, jobject thisobj, jint n1, jint n2)
{
jint res;
res=n1+n2;
return res;
}
 
******** Compiling the file *********
Command :-
gescoe@gescoe-optiplex-3020:~/Documents/AY21-22/LP-1$ gcc -c -fPIC -I
/usr/lib/jvm/java-1.8.0-openjdk-amd64/include
-I/usr/lib/jvm/java-1.8.0-openjdk-amd64/include/linux testJni1.c -o testJni1.o

***** After That RUn These Two Commands *******

gescoe@gescoe-optiplex-3020:~/Documents/AY21-22/LP-1$ gcc -shared -fPIC -o
libnative.so testJni1.o -lc

gescoe@gescoe-optiplex-3020:~/Documents/AY21-22/LP-1$ java -Djava.library.path=. testJni1

###################################################################################################

This is a **Java Native Interface (JNI)** program, where a Java program uses a **Dynamic Link Library (DLL)** written in C language to perform an addition operation. Let's break it down step by step.

### **Concept**
- **JNI** allows Java programs to call functions written in other languages like C/C++.
- **Dynamic Link Library (DLL)** or **Shared Library** is a compiled file containing functions that can be used by other programs.

### **Files Involved**
1. **testJni1.java**: Java code to use the native addition function.
2. **testJni1.c**: C code implementing the addition function.
3. **testJni1.h**: Header file generated automatically by the `javac` command for the C code.
4. **libnative.so**: The shared library file generated by compiling the C code.

### **Steps**

#### **1. Java Program (`testJni1.java`)**
```java
public class testJni1 {
    static {
        System.loadLibrary("native");
    }

    public static void main(String args[]) {
        System.out.println("Addition is " + new testJni1().add(10, 20));
    }

    private native int add(int n1, int n2);
}
```

**Explanation**:
- **`System.loadLibrary("native")`**: This line loads the shared library `libnative.so` (on Linux) or `native.dll` (on Windows).
- **`native`** keyword: It tells Java that the `add` method is implemented in a native language (C/C++).
- **`add(int n1, int n2)`**: This is a declaration of the native method that will be defined in C.

**Execution**:
- When you run this Java program, it calls the C function to perform the addition operation.

#### **2. Compiling the Java File**
```bash
javac -h . testJni1.java
```

**Explanation**:
- **`javac`**: Compiles the Java file.
- **`-h .`**: Generates the header file (`testJni1.h`) in the current directory. This header file is needed for the C program.

#### **3. C Program (`testJni1.c`)**
```c
#include <jni.h>
#include <stdio.h>
#include "testJni1.h"

JNIEXPORT jint JNICALL Java_testJni1_add(JNIEnv *env, jobject thisobj, jint n1, jint n2) {
    jint res;
    res = n1 + n2;
    return res;
}
```

**Explanation**:
- **`#include <jni.h>`**: This includes the JNI header file with necessary functions and types for JNI.
- **`#include "testJni1.h"`**: This includes the header file generated by the `javac -h` command.
- **`JNIEXPORT jint JNICALL Java_testJni1_add`**: This is the function signature generated based on the Java method `add`. It follows the JNI naming convention: `Java_ClassName_MethodName`.
  - **`JNIEnv *env`**: Pointer to the JNI environment, allowing interaction with the JVM.
  - **`jobject thisobj`**: Reference to the Java object that called this method.
  - **`jint n1, jint n2`**: These are the two integer parameters from Java.
- **`jint res = n1 + n2;`**: Performs the addition operation.
- **`return res;`**: Returns the result to the Java program.

#### **4. Compiling the C File**
```bash
gcc -c -fPIC -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include -I /usr/lib/jvm/java-1.8.0-openjdk-amd64/include/linux testJni1.c -o testJni1.o
```

**Explanation**:
- **`gcc`**: The GNU C Compiler is used to compile the C code.
- **`-c`**: Compiles the source file without linking.
- **`-fPIC`**: Generates position-independent code for shared libraries.
- **`-I`**: Specifies the paths to the JNI header files (`jni.h`).
- **`testJni1.c`**: The C source file.
- **`-o testJni1.o`**: Specifies the output file (`testJni1.o`).

#### **5. Creating the Shared Library**
```bash
gcc -shared -fPIC -o libnative.so testJni1.o -lc
```

**Explanation**:
- **`-shared`**: Creates a shared library.
- **`-o libnative.so`**: Specifies the output shared library file.
- **`testJni1.o`**: The compiled object file from the C source.
- **`-lc`**: Links the C standard library.

- The generated shared library is named **`libnative.so`**.

#### **6. Running the Java Program**
```bash
java -Djava.library.path=. testJni1
```

**Explanation**:
- **`-Djava.library.path=.`**: Sets the library path to the current directory so that Java can find `libnative.so`.
- **`testJni1`**: The name of the Java class to execute.

#### **Output**:
```
Addition is 30
```

### **How It Works**:
1. **Java Program (`testJni1.java`)**:
   - Calls the native method `add`.
2. **JNI (Java Native Interface)**:
   - Passes the call from Java to the C function `Java_testJni1_add`.
3. **C Function (`testJni1.c`)**:
   - Performs the addition and returns the result.
4. **Java Program**:
   - Prints the result received from the C function.

### **Key Points to Remember**:
- **JNI Workflow**:
  - Declare a native method in Java.
  - Implement the method in C/C++.
  - Compile and link to create a shared library.
  - Load the shared library in Java.
- **Compiling Steps**:
  - Compile the Java file with header generation.
  - Implement and compile the C function.
  - Create a shared library from the C object file.
  - Run the Java program specifying the library path.

This integration allows Java to use lower-level C/C++ functions, which can be faster for certain operations or necessary for accessing system-level features not available in Java.